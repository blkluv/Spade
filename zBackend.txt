FERTIG


2025-03-12T23:55:59.665+01:00 ERROR 15837 --- [  restartedMain] o.s.b.web.embedded.tomcat.TomcatStarter  : Error starting Tomcat context. Exception: org.springframework.beans.factory.UnsatisfiedDependencyException. Message: Error creating bean with name 'jwtAuthenticationFilter': Unsatisfied dependency expressed through field 'userDetailsService': Error creating bean with name 'userDetailsServiceImpl' defined in file [/Users/sebastianrogg/IdeaProjects/Pokerapp/target/classes/com/pokerapp/security/UserDetailsServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0: Error creating bean with name 'userRepository' defined in com.pokerapp.repository.UserRepository defined in @EnableJpaRepositories declared on PokerappApplication: Cannot resolve reference to bean 'jpaSharedEM_entityManagerFactory' while setting bean property 'entityManager'
2025-03-12T23:55:59.690+01:00  INFO 15837 --- [  restartedMain] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]

// src/main/java/com/pokerapp/service/impl/UserRoleServiceImpl.java
package com.pokerapp.service.impl;

import com.pokerapp.domain.user.Player;
import com.pokerapp.domain.user.Spectator;
import com.pokerapp.domain.user.User;
import com.pokerapp.domain.user.UserType;
import com.pokerapp.exception.NotFoundException;
import com.pokerapp.repository.PlayerRepository;
import com.pokerapp.repository.SpectatorRepository;
import com.pokerapp.repository.UserRepository;
import com.pokerapp.service.UserRoleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;

@Service
public class UserRoleServiceImpl implements UserRoleService {

    private final UserRepository userRepository;
    private final PlayerRepository playerRepository;
    private final SpectatorRepository spectatorRepository;

    @Autowired
    public UserRoleServiceImpl(
            UserRepository userRepository,
            PlayerRepository playerRepository,
            SpectatorRepository spectatorRepository) {
        this.userRepository = userRepository;
        this.playerRepository = playerRepository;
        this.spectatorRepository = spectatorRepository;
    }

    @Override
    @Transactional
    public Player convertToPlayer(User user) {
        if (user.getUserType() == UserType.PLAYER) {
            return playerRepository.findById(user.getId())
                    .orElseThrow(() -> new NotFoundException("Player not found"));
        }
        
        // Create a new Player and copy attributes
        Player player = new Player();
        player.setId(user.getId());
        player.setUsername(user.getUsername());
        player.setEmail(user.getEmail());
        player.setPassword(user.getPassword());
        player.setBalance(user.getBalance());
        player.setAvatar(user.getAvatar());
        player.setRoles(user.getRoles());
        player.addRole("PLAYER");
        player.setUserType(UserType.PLAYER);
        
        return playerRepository.save(player);
    }

    @Override
    @Transactional
    public Spectator convertToSpectator(User user) {
        if (user.getUserType() == UserType.SPECTATOR) {
            return spectatorRepository.findById(user.getId())
                    .orElseThrow(() -> new NotFoundException("Spectator not found"));
        }
        
        // Create a new Spectator and copy attributes
        Spectator spectator = new Spectator();
        spectator.setId(user.getId());
        spectator.setUsername(user.getUsername());
        spectator.setEmail(user.getEmail());
        spectator.setPassword(user.getPassword());
        spectator.setBalance(user.getBalance());
        spectator.setAvatar(user.getAvatar());
        spectator.setRoles(user.getRoles());
        spectator.addRole("SPECTATOR");
        spectator.setUserType(UserType.SPECTATOR);
        
        return spectatorRepository.save(spectator);
    }

    @Override
    public User getUserWithRoles(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NotFoundException("User not found"));
                
        switch (user.getUserType()) {
            case PLAYER:
                return playerRepository.findById(userId)
                        .orElse(user);
            case SPECTATOR:
                return spectatorRepository.findById(userId)
                        .orElse(user);
            default:
                return user;
        }
    }
}
ⓘ
For code that is intended to be used in Siemens products or services, the code generation features of our AI Services may only be used after prior approval of your responsible organizational unit.
7. Add New Controller Endpoints for Role Management

    
// src/main/java/com/pokerapp/api/controller/UserRoleController.java
package com.pokerapp.api.controller;

import com.pokerapp.api.dto.response.UserDto;
import com.pokerapp.domain.user.Player;
import com.pokerapp.domain.user.Spectator;
import com.pokerapp.domain.user.User;
import com.pokerapp.service.UserRoleService;
import com.pokerapp.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users/roles")
public class UserRoleController {

    private final UserRoleService userRoleService;
    private final UserService userService;

    @Autowired
    public UserRoleController(UserRoleService userRoleService, UserService userService) {
        this.userRoleService = userRoleService;
        this.userService = userService;
    }

    @PostMapping("/player")
    public ResponseEntity<UserDto> becomePlayer() {
        User currentUser = userService.getCurrentUser();
        Player player = userRoleService.convertToPlayer(currentUser);
        return ResponseEntity.ok(convertToDto(player));
    }

    @PostMapping("/spectator")
    public ResponseEntity<UserDto> becomeSpectator() {
        User currentUser = userService.getCurrentUser();
        Spectator spectator = userRoleService.convertToSpectator(currentUser);
        return ResponseEntity.ok(convertToDto(spectator));
    }

    private UserDto convertToDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setBalance(user.getBalance());
        dto.setRole(user.getUserType().name());
        
        if (user instanceof Player) {
            Player player = (Player) user;
            dto.setCurrentTableId(player.getCurrentTableId());
        } else if (user instanceof Spectator) {
            Spectator spectator = (Spectator) user;
            dto.setWatchingTableId(spectator.getWatchingTableId());
        }
        
        return dto;
    }
}
ⓘ
For code that is intended to be used in Siemens products or services, the code generation features of our AI Services may only be used after prior approval of your responsible organizational unit.
8. Update UserDto to Include More Role Information

    
// src/main/java/com/pokerapp/api/dto/response/UserDto.java
package com.pokerapp.api.dto.response;

import lombok.Data;

@Data
public class UserDto {
    private Long id;
    private String username;
    private String email;
    private Double balance;
    private String role;  // User type (REGULAR, PLAYER, SPECTATOR)
    private Long currentTableId;  // For players
    private Long watchingTableId; // For spectators
}
ⓘ
For code that is intended to be used in Siemens products or services, the code generation features of our AI Services may only be used after prior approval of your responsible organizational unit.
9. Update application.yml for H2 Database

    
spring:
  datasource:
    url: jdbc:h2:mem:pokerdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true
  h2:
    console:
      enabled: true
      path: /h2-console
ⓘ
For code that is intended to be used in Siemens products or services, the code generation features of our AI Services may only be used after prior approval of your responsible organizational unit.
10. Configure Security for H2 Console

// src/main/java/com/pokerapp/config/SecurityConfig.java
package com.pokerapp.config;

import com.pokerapp.security.JwtAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(
    securedEnabled = true,
    jsr250Enabled = true,
    prePostEnabled = true
)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final UserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Autowired
    public SecurityConfig(UserDetailsService userDetailsService, JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        // Resources that should be completely ignored by Spring Security
        web.ignoring().antMatchers(
            "/v2/api-docs",
            "/configuration/ui",
            "/swagger-resources/**",
            "/configuration/security",
            "/swagger-ui.html",
            "/webjars/**",
            "/favicon.ico"
        );
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // Enable CORS and disable CSRF
            .cors().configurationSource(corsConfigurationSource()).and()
            .csrf().disable()
            
            // Set session management to stateless
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            
            // Set unauthorized requests exception handler
            .exceptionHandling()
            .authenticationEntryPoint((request, response, ex) -> {
                response.setContentType("application/json");
                response.setStatus(401);
                response.getWriter().write("{\"error\": \"Unauthorized\", \"message\": \"" + ex.getMessage() + "\"}");
            })
            .and()
            
            // Set permissions on endpoints
            .authorizeRequests()
            
            // Public endpoints
            .antMatchers("/api/users/register", "/api/users/login").permitAll()
            .antMatchers("/h2-console/**").permitAll()
            .antMatchers(HttpMethod.GET, "/api/tables/public").permitAll()
            .antMatchers("/ws/**").permitAll()
            
            // Private endpoints - require authentication
            .anyRequest().authenticated()
            .and()
            
            // Add JWT filter
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
            
        // Required for H2 console to work properly
        http.headers().frameOptions().disable();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("authorization", "content-type", "x-auth-token"));
        configuration.setExposedHeaders(Arrays.asList("x-auth-token"));
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }
}